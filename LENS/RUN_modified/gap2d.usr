C-----------------------------------------------------------------------
      subroutine uservp(i,j,k,eg) ! set variable properties
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)

      udiff  = 0.0
      utrans = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userf(i,j,k,eg) ! set acceleration term
c
c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
c
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
c     e = gllel(eg)

      ffx = 0.0
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq(i,j,k,eg) ! set source term
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      integer e,f,eg
      e = gllel(eg)

      qvol   = 0

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc(i,j,k,f,eg) ! set up boundary conditions
c     NOTE ::: This subroutine MAY NOT be called by every process
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,f,eg


      ux   = 0.0
      uy   = 0.0
      uz   = 0.0
      temp = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric(i,j,k,eg) ! set up initial conditions
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,f,eg

      ux   = 0.0
      uy   = 0.0
      uz   = 0.0
      temp = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat   ! This routine to modify element vertices
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine stretch_outside_circ(diam,gap)
      include 'SIZE'
      include 'TOTAL'

      n = nx1*ny1*nz1*nelv
      xmn=glmin(xm1,n)
      xmx=glmax(xm1,n)
      ymn=glmin(ym1,n)
      ymx=glmax(ym1,n)

      r0   = diam/2.       ! call prs('Input protected radius:$')
      x1   = r0   + gap/2  ! New box size
      x0   = -x1 
      y1   =  x1 
      y0   = -y1 

      call stretch_outside_circ2(r0,x0,x1,y0,y1,xmn,xmx,ymn,ymx)

      return
      end
c-----------------------------------------------------------------------
      subroutine stretch_outside_circ2(r0,x0,x1,y0,y1,xmn,xmx,ymn,ymx)
      include 'SIZE'
      include 'TOTAL'

      n = nx1*ny1*nz1*nelv

      scalex = (x1-x0)/(xmx-xmn)
      scaley = (y1-y0)/(ymx-ymn)

      xbr  = (xmn+xmx)/2  ! Midpoint of current data
      ybr  = (ymn+ymx)/2
      xbrt = (x0+x1)/2    ! Target midpoint
      ybrt = (y0+y1)/2

      do i=1,n
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)

         xnt= xbrt + scalex*(xx-xbr) ! Temporary new point
         ynt= ybrt + scaley*(yy-ybr)

         bb = blend_circ_in_box(xx,yy,r0,xmn,xmx,ymn,ymx)

         dx = (xnt-xx)*(1-bb)
         dy = (ynt-yy)*(1-bb)

         xn = xx+dx   ! Now in a proper rectangle to combine
         yn = yy+dy   ! two arc-segment transformations

         xm1(i,1,1,1) = xn
         ym1(i,1,1,1) = yn

      enddo

      return
      end
c-----------------------------------------------------------------------
      subroutine set_diam_gap(diam,gap)
      include 'SIZE'
      include 'TOTAL'

      n = lx1*ly1*lz1*nelt

      diam0 = 1.0  ! Default initial diameter
      gap0  = gap*(diam0/diam)

      call stretch_outside_circ(diam0,gap0)

      scale = diam/diam0
      call cmult(xm1,scale,n)
      call cmult(ym1,scale,n)
      call cmult(zm1,scale,n)

      return
      end
c-----------------------------------------------------------------------
      function blend_circ_in_box(x,y,r0,x0i,x1i,y0i,y1i)
      real p(2),v(2,5)
      real o(2)
      save o
      data o / 0. , 0. /

      blend_circ_in_box = 1.

      r=x*x+y*y
      if (r.le.r0*r0) return

      ey = 1.e-6*(y1i-y0i)   ! Put a slight tolerance on box size
      ex = 1.e-6*(x1i-x0i)
      x0 = x0i-ex
      x1 = x1i+ex
      y0 = y0i-ey
      y1 = y1i+ey

      r = sqrt(r)
      t = atan2(y,x)

      p(1)=x
      p(2)=y

      do i=1,5
         v(1,i)=x0
         v(2,i)=y0
      enddo
      v(1,2)=x1
      v(1,3)=x1
      v(2,3)=y1
      v(2,4)=y1
      call cmult(v,2.0,10) ! Make domain bigger for "in_triangle" check

      ks=0
      do k=1,4
         in = in_triangle(p,o,v(1,k),v(1,k+1)) ! triangle: [ o vk vk1 ]
         if (in.gt.0) then
           if (k.eq.1) then       !  Lower y boundary
              yc = r0*sin(t)
              b  = (y-y0)/(yc-y0)
           elseif (k.eq.2) then   ! Right x boundary
              xc = r0*cos(t)
              b  = (x-x1)/(xc-x1)
           elseif (k.eq.3) then   ! Upper y boundary
              yc = r0*sin(t)
              b  = (y-y1)/(yc-y1)
           else                   !  Left x boundary
              xc = r0*cos(t) 
              b  = (x-x0)/(xc-x0) 
           endif
           blend_circ_in_box = max(b,0.)
           return
         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      function in_triangle(p,a,b,c)
      real p(2),a(2),b(2),c(2)
      real v0(2),v1(2),v2(2),invdenom

      call sub3(v0,c,a,2) ! v0 = c-a
      call sub3(v1,b,a,2) ! v1 = b-a
      call sub3(v2,p,a,2) ! v2 = p-a

      d00 = vlsc2(v0,v0,2)
      d01 = vlsc2(v0,v1,2)
      d02 = vlsc2(v0,v2,2)
      d11 = vlsc2(v1,v1,2)
      d12 = vlsc2(v1,v2,2)

c     Compte barycentric coordinates

      invdenom = 1./(d00*d11-d01*d01)
      u=(d11*d02-d01*d12)*invdenom
      v=(d00*d12-d01*d02)*invdenom

      in_triangle = 0
      if (u.ge.0.and.v.ge.0.and.(u+v).lt.1) in_triangle = 1

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2  ! This routine to modify mesh coordinates
      include 'SIZE'
      include 'TOTAL'

      parameter(lt=lx1*ly1*lz1*lelt)
      common /megeom/ ox(lt),oy(lt),oz(lt)


      call opcopy(ox,oy,oz,xm1,ym1,zm1)

      diam = 150
      gap  = 10
      call set_diam_gap(diam,gap)

c     call fix_geom

      call opsub2(ox,oy,oz,xm1,ym1,zm1)

      call outpost(ox,oy,oz,pr,t,'   ')
      stop

      return
      end
c-----------------------------------------------------------------------
