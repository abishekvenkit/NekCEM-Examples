c-----------------------------------------------------------------------
c
c     Plane wave striking a cylindrical resonator
c
c-----------------------------------------------------------------------
      subroutine userinc(tt,incfhx,incfhy,incfhz,incfex,incfey,incfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /userparam/ omega,period,lambda
      real omega,period,lambda

      common /userincident/ ninc,incindex(lxzfl)
      integer ninc,incindex

      real tt
      real incfhx(lxzfl),incfhy(lxzfl),incfhz(lxzfl)
      real incfex(lxzfl),incfey(lxzfl),incfez(lxzfl)

      integer i,j,k
      real zz,eps,mu,kz,eta,uinc
      real ramp

      do i = 1,ninc
         j = incindex(i)
         k = cemface(j)
         zz = zm1(k,1,1,1)
         eps = permittivity(k)
         mu = permeability(k)
         eta = sqrt(mu/eps)
         kz = omega*sqrt(mu*eps)
         uinc = ramp(tt/(3.0*period))*sin(-kz*zz-omega*tt)
         incfhx(j) = incfhx(j)+uinc
         incfey(j) = incfey(j)+eta*uinc
      enddo

      return
      end
c-----------------------------------------------------------------------
      function ramp(tt)
c-----------------------------------------------------------------------
c     Monotonic function that goes from 0 to 1 on the interval [0, 1].
      implicit none

      real ramp
      real tt

      ramp = 0.5*(1.0+erf(5.0*(tt-0.5)))

      return
      end
c-----------------------------------------------------------------------
      subroutine userini(tt,hx,hy,hz,ex,ey,ez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real hx(lpts),hy(lpts),hz(lpts)
      real ex(lpts),ey(lpts),ez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersol(tt,solhx,solhy,solhz,solex,soley,solez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real solhx(lpts),solhy(lpts),solhz(lpts)
      real solex(lpts),soley(lpts),solez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine usersrc(tt,srchx,srchy,srchz,srcex,srcey,srcez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real srchx(lpts),srchy(lpts),srchz(lpts)
      real srcex(lpts),srcey(lpts),srcez(lpts)

      return
      end
c-----------------------------------------------------------------------
      subroutine userfsrc(tt,srcfhx,srcfhy,srcfhz,srcfex,srcfey,srcfez)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      real tt
      real srcfhx(lxzfl),srcfhy(lxzfl),srcfhz(lxzfl)
      real srcfex(lxzfl),srcfey(lxzfl),srcfez(lxzfl)

      return
      end
c-----------------------------------------------------------------------
      subroutine uservp(ix,iy,iz,iel)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'
      include 'PML'
      include 'mpif.h'

      common /userparam/ omega,period,lambda
      real omega,period,lambda

      common /userincident/ ninc,incindex(lxzfl)
      integer ninc,incindex

      common /scaling/ length,sxy,sz,radius,gap,cylbot,cyltop
      real length,sxy,sz,radius,gap,cylbot,cyltop

      common /userout/ disp,outindex(lxzfl),nout
      integer outindex,nout
      integer(8) disp

c     These don't do anything! This is a temporary measure until
c
c     https://github.com/NekCEM/NekCEM/issues/12
c
c     is resolved.
      integer ix,iy,iz,iel

      logical markinc,markout
      integer i,e,f,j,k,nx1_2,ierr
      integer disps(0:lp-1),tmp(0:lp-1)
      real xx,yy,zz,rr,r0
      real c0,twopi,tol
      parameter (
     $     c0 = 299792458,      ! speed of light, in m/s
     $     twopi = 8.0*atan(1.0),
     $     tol = 1e-8)

c     Nondimensionalize the wavelength
      omega = twopi/lambda
      period = twopi/omega
      if (nid.eq.0) then
         write(*,*) 'uservp: wavelength lambda = ',lambda
         write(*,*) 'uservp: frequency omega = ',omega
         write(*,*) 'uservp: period = ',period
      endif

      nx1_2 = nx1/2
c     Set the permittivities
      do e = 1,nelt
        xx = xm1(nx1_2,nx1_2,nx1_2,e)
        yy = ym1(nx1_2,nx1_2,nx1_2,e)
        zz = zm1(nx1_2,nx1_2,nx1_2,e)
        rr = sqrt(xx**2+yy**2)
        if (zz.gt.cylbot.and.zz.lt.cyltop) then
c     Inside the resonator
           if (rr.lt.r0) then
              do i = 1,nxyz 
                 j = i+nxyz*(e-1)
                 permittivity(j) = 2.5031**2
                 permeability(j) = 1.0
              enddo
           else 
c     Inside the lens and Outside the resonator
              do i = 1,nxyz
                 j = i+nxyz*(e-1)
                 permittivity(j) = 1.41**2
                 permeability(j) = 1.0
              enddo
           endif
        else
c     Outside the lens
           do i = 1,nxyz
              j = i+nxyz*(e-1)
              permittivity(j) = 1.0
              permeability(j) = 1.0
           enddo
        endif
      enddo

c     Mark where the incident field needs to be added
      ninc = 0
      do e = 1,nelt
         do f = 1,nfaces
            markinc = .true.
            do i = 1,nxzf
c     j is the global face number
               j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
c     k is the volume global number associated with face j.
               k = cemface(j)
               if (pmltag(e).eq.0
     $              .or.abs(pmlinner(6)-zm1(k,1,1,1)).gt.tol) then
                  markinc = .false.
                  exit
               endif
            enddo
            if (markinc) then
               do i = 1,nxzf
                  ninc = ninc+1
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                  incindex(ninc) = j
               enddo
            endif
         enddo
      enddo

      if (nid.eq.0) write(*,*) 'uservp: bottom of the PML begins at ',
     $     pmlinner(5)
c     Mark where we want to write the H field to file
      nout = 0
      do e = 1,nelt
         do f = 1,nfaces
            markout = .true.
            do i = 1,nxzf
               j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
               k = cemface(j)
               if (pmltag(e).ne.0
     $              .or.abs(pmlinner(5)-zm1(k,1,1,1)).gt.tol) then
                  markout = .false.
                  exit
               endif
            enddo
            if (markout) then
               do i = 1,nxzf
                  nout = nout+1
                  j = (e-1)*nxzf*nfaces+nxzf*(f-1)+i
                  outindex(nout) = j
               enddo
            endif
         enddo
      enddo
c     Compute the displacements in the file for the different processes
c
c     Step 1: figure out how many doubles each process needs to write;
c     store the data in tmp
      if (nid.eq.0) then
         tmp(0) = nout
         do i = 1,np-1
            call mpi_recv(tmp(i),1,mpi_integer,i,i,mpi_comm_world,
     $           ierr,mpi_status_ignore,ierr)
         enddo
c     Step 2: convert the number of doubles each process needs to write
c     into a displacement in the file
         disps(0) = 0
         do i = 1,np-1
            disps(i) = 8*tmp(i-1)+disps(i-1)
         enddo
      else
         call mpi_send(nout,1,mpi_integer,0,nid,mpi_comm_world,ierr)
      endif

      call mpi_bcast(disps,np,mpi_integer,0,mpi_comm_world,ierr)
      disp = disps(nid)

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
c-----------------------------------------------------------------------
      implicit none

      return
      end
c-----------------------------------------------------------------------      
       subroutine usrdat2
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'GEOM'
      include 'PML'
      include 'INPUT'

      common /scaling/ length,sxy,sz,radius,gap,cylbot,cyltop
      real length,sxy,sz,radius,gap,cylbot,cyltop,diam

      common /userparam/ omega,period,lambda
      real omega,period,lambda

      integer i
      real xmin,xmax,ymin,ymax,zmin,zmax,height
      real glmax,glmin

c      diam = param(70)*2
c      gap  = 46
c      call set_diam_gap(diam,gap)

      return
      end
c-----------------------------------------------------------------------
      subroutine set_diam_gap(diam,gap)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'

      n = lx1*ly1*lz1*nelt

      diam0 = 1.0  ! Default initial diameter
      gap0  = gap*(diam0/diam)

      call stretch_outside_circ(diam0,gap0)

      scale = diam/diam0
      call cmult(xm1,scale,n)
      call cmult(ym1,scale,n)
      call cmult(zm1,scale,n)

      return
      end
c-----------------------------------------------------------------------
      subroutine stretch_outside_circ(diam,gap)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'

      n = nx1*ny1*nz1*nelv
      xmn0=glmin(xm1,n)
      xmx=glmax(xm1,n)
      ymn0=glmin(ym1,n)
      ymx=glmax(ym1,n)

      r0   = diam/2.       ! call prs('Input protected radius:$')
      x1   = r0   + gap/2  ! New box size
      x0   = -x1 
      y1   =  x1 
      y0   = -y1 

      call stretch_outside_circ2(r0,x0,x1,y0,y1,xmn0,xmx,ymn0,ymx)

      return
      end
c-----------------------------------------------------------------------
      subroutine stretch_outside_circ2(r0,x0,x1,y0,y1,xmn0,xmx,ymn0,ymx)
c-----------------------------------------------------------------------
      include 'SIZE'
      include 'TOTAL'

      n = nx1*ny1*nz1*nelv

      scalex = (x1-x0)/(xmx-xmn0)
      scaley = (y1-y0)/(ymx-ymn0)

      xbr  = (xmn0+xmx)/2  ! Midpoint of current data
      ybr  = (ymn0+ymx)/2
      xbrt = (x0+x1)/2    ! Target midpoint
      ybrt = (y0+y1)/2

      do i=1,n
         xx = xm1(i,1,1,1)
         yy = ym1(i,1,1,1)

         xnt= xbrt + scalex*(xx-xbr) ! Temporary new point
         ynt= ybrt + scaley*(yy-ybr)

         bb = blend_circ_in_box(xx,yy,r0,xmn0,xmx,ymn0,ymx)

         dx = (xnt-xx)*(1-bb)
         dy = (ynt-yy)*(1-bb)

         xn = xx+dx   ! Now in a proper rectangle to combine
         yn = yy+dy   ! two arc-segment transformations

         xm1(i,1,1,1) = xn
         ym1(i,1,1,1) = yn

      enddo

      return
      end
c-----------------------------------------------------------------------
      function blend_circ_in_box(x,y,r0,x0i,x1i,y0i,y1i)
c-----------------------------------------------------------------------      
      real p(2),v(2,5)
      real o(2)
      save o
      data o / 0. , 0. /

      blend_circ_in_box = 1.

      r=x*x+y*y
      if (r.le.r0*r0) return

      ey = 1.e-6*(y1i-y0i)   ! Put a slight tolerance on box size
      ex = 1.e-6*(x1i-x0i)
      x0 = x0i-ex
      x1 = x1i+ex
      y0 = y0i-ey
      y1 = y1i+ey

      r = sqrt(r)
      t = atan2(y,x)

      p(1)=x
      p(2)=y

      do i=1,5
         v(1,i)=x0
         v(2,i)=y0
      enddo
      v(1,2)=x1
      v(1,3)=x1
      v(2,3)=y1
      v(2,4)=y1
      call cmult(v,2.0,10) ! Make domain bigger for "in_triangle" check

      ks=0
      do k=1,4
         in = in_triangle(p,o,v(1,k),v(1,k+1)) ! triangle: [ o vk vk1 ]
         if (in.gt.0) then
           if (k.eq.1) then       !  Lower y boundary
              yc = r0*sin(t)
              b  = (y-y0)/(yc-y0)
           elseif (k.eq.2) then   ! Right x boundary
              xc = r0*cos(t)
              b  = (x-x1)/(xc-x1)
           elseif (k.eq.3) then   ! Upper y boundary
              yc = r0*sin(t)
              b  = (y-y1)/(yc-y1)
           else                   !  Left x boundary
              xc = r0*cos(t) 
              b  = (x-x0)/(xc-x0) 
           endif
           blend_circ_in_box = max(b,0.)
           return
         endif
      enddo

      return
      end
c-----------------------------------------------------------------------
      function in_triangle(p,a,b,c)
c-----------------------------------------------------------------------      
      real p(2),a(2),b(2),c(2)
      real v0(2),v1(2),v2(2),invdenom

      call sub3(v0,c,a,2) ! v0 = c-a
      call sub3(v1,b,a,2) ! v1 = b-a
      call sub3(v2,p,a,2) ! v2 = p-a

      d00 = vlsc2(v0,v0,2)
      d01 = vlsc2(v0,v1,2)
      d02 = vlsc2(v0,v2,2)
      d11 = vlsc2(v1,v1,2)
      d12 = vlsc2(v1,v2,2)

c     Compte barycentric coordinates

      invdenom = 1./(d00*d11-d01*d01)
      u=(d11*d02-d01*d12)*invdenom
      v=(d00*d12-d01*d02)*invdenom

      in_triangle = 0
      if (u.ge.0.and.v.ge.0.and.(u+v).lt.1) in_triangle = 1

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'TOTAL'
      include 'EMWAVE'

      common /ccpu/ cpu_t,cpu_dtime,cpu_chk
      real cpu_t,cpu_dtime,cpu_chk

      common /userout/ disp,outindex(lxzfl),nout
      integer outindex,nout
      integer(8) disp

      character(100) filename
      integer i,j,k
      real cpu_p_t
      real l2(6),linf(6),buf(lpts)

c     Dump the x component of the H field below the resonator into a
c     file
      if (istep.eq.0) then
         do i = 1,nout
            j = outindex(i)
            k = cemface(j)
            buf(i) = xm1(k,1,1,1)
         enddo
         call write_buf('vtk/xcoordinates.dat',buf,nout,disp)
         do i = 1,nout
            j = outindex(i)
            k = cemface(j)
            buf(i) = ym1(k,1,1,1)
         enddo
         call write_buf('vtk/ycoordinates.dat',buf,nout,disp)
      endif
      if (mod(istep,25).eq.0) then
         do i = 1,nout
            j = outindex(i)
            k = cemface(j)
            buf(i) = hn(k,1)
         enddo
         write(filename,"(A6,I0.7,A4)") 'vtk/hx',istep,'.dat'
         call write_buf(filename,buf,nout,disp)
      endif

      if (istep.le.10.or.mod(istep,iocomm).eq.0) then
         call usersol
     $     (time,shn(1,1),shn(1,2),shn(1,3),sen(1,1),sen(1,2),sen(1,3))
         call cem_error(hn(1,1),shn(1,1),errhn(1,1),npts,l2(1),linf(1))
         call cem_error(hn(1,2),shn(1,2),errhn(1,2),npts,l2(2),linf(2))
         call cem_error(hn(1,3),shn(1,3),errhn(1,3),npts,l2(3),linf(3))
         call cem_error(en(1,1),sen(1,1),erren(1,1),npts,l2(4),linf(4))
         call cem_error(en(1,2),sen(1,2),erren(1,2),npts,l2(5),linf(5))
         call cem_error(en(1,3),sen(1,3),erren(1,3),npts,l2(6),linf(6))

         call userprint(istep,time,dt,l2,linf,cpu_t,cpu_p_t)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userprint(istep,tt,dt,l2,linf,t1,t2)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'

      integer istep
      real tt,dt,t1,t2
      real l2(6),linf(6)

      integer k

      if (nid.eq.0) then
         write(6,101) istep,nelt,nx1-1,npts,tt,dt,(l2(k),k=1,6),t1,t2
         write(6,102) istep,nelt,nx1-1,npts,tt,dt,(linf(k),k=1,6),t1,t2
      endif

 101  format(/,i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: L2')
 102  format(  i10,i6,i4,i9,1p9e10.3,e9.2,' CPU: Linf')

      return
      end
c-----------------------------------------------------------------------
      subroutine write_buf(filename,buf,nbuf,disp)
c-----------------------------------------------------------------------
      implicit none
      include 'SIZE'
      include 'mpif.h'

      character(len=*) filename
      integer nbuf
      integer(8) disp
      real buf(lpts)

      integer fileno,ierr

      call mpi_file_open(mpi_comm_world,filename,
     $     mpi_mode_wronly+mpi_mode_create,mpi_info_null,
     $     fileno,ierr)
      call mpi_file_set_view(fileno,disp,mpi_double,
     $     mpi_double,'native',mpi_info_null,ierr)
      call mpi_file_write(fileno,buf,nbuf,mpi_double,
     $     mpi_status_ignore,ierr)
      call mpi_file_close(fileno,ierr)

      return
      end
c-----------------------------------------------------------------------
